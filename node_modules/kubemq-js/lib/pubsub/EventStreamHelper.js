"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventStreamHelper = void 0;
const eventTypes_1 = require("../pubsub/eventTypes");
class EventStreamHelper {
    constructor() {
        this.queuesUpStreamHandler = null;
        this.futureResponse = new Promise((resolve, reject) => {
            this.resolveResponse = resolve;
            this.rejectResponse = reject;
        });
    }
    async sendEventMessage(kubeMQClient, event) {
        if (!this.queuesUpStreamHandler) {
            this.queuesUpStreamHandler = kubeMQClient.grpcClient.SendEventsStream();
            // Setup handlers for the duplex stream
            this.queuesUpStreamHandler.on('data', (result) => {
                this.resolveResponse(eventTypes_1.EventsSendResult.decode(result));
            });
            this.queuesUpStreamHandler.on('error', (err) => {
                console.error('Error in EventSendResult: ', err);
                const sendResult = new eventTypes_1.EventsSendResult();
                sendResult.error = err.message;
                this.rejectResponse(sendResult);
            });
            this.queuesUpStreamHandler.on('end', () => {
                console.log('EventSendResult onCompleted.');
            });
        }
        // Send the event
        this.queuesUpStreamHandler.write(event);
    }
    async sendEventStoreMessage(kubeMQClient, event) {
        if (!this.queuesUpStreamHandler) {
            this.queuesUpStreamHandler = kubeMQClient.grpcClient.SendEventsStream();
            // Setup handlers for the duplex stream
            this.queuesUpStreamHandler.on('data', (result) => {
                this.resolveResponse(eventTypes_1.EventsSendResult.decode(result));
            });
            this.queuesUpStreamHandler.on('error', (err) => {
                console.error('Error in EventSendResult: ', err);
                const sendResult = new eventTypes_1.EventsSendResult();
                sendResult.error = err.message;
                this.rejectResponse(sendResult);
            });
            this.queuesUpStreamHandler.on('end', () => {
                console.log('EventSendResult onCompleted.');
            });
        }
        // Send the event
        this.queuesUpStreamHandler.write(event);
        try {
            return await this.futureResponse;
        }
        catch (err) {
            console.error('Error waiting for response: ', err);
            throw new Error('Failed to get response');
        }
    }
}
exports.EventStreamHelper = EventStreamHelper;
//# sourceMappingURL=EventStreamHelper.js.map
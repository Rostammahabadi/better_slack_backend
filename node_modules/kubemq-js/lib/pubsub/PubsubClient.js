"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubsubClient = void 0;
const KubeMQClient_1 = require("../client/KubeMQClient");
const pb = require("../protos");
const utils_1 = require("../common/utils");
const grpc = require("@grpc/grpc-js");
const common_1 = require("../common/common");
const eventTypes_1 = require("./eventTypes");
const EventStreamHelper_1 = require("./EventStreamHelper");
class PubsubClient extends KubeMQClient_1.KubeMQClient {
    constructor(Options) {
        super(Options);
        this.eventStreamHelper = new EventStreamHelper_1.EventStreamHelper();
    }
    async sendEventsMessage(msg) {
        const pbMessage = new pb.kubemq.Event();
        pbMessage.EventID = msg.id || utils_1.Utils.uuid();
        pbMessage.ClientID = msg.clientId || this.clientId;
        pbMessage.Channel = msg.channel;
        pbMessage.Body = typeof msg.body === 'string' ? new TextEncoder().encode(msg.body) : msg.body;
        pbMessage.Metadata = msg.metadata;
        if (msg.tags != null) {
            pbMessage.Tags = msg.tags;
        }
        pbMessage.Store = false;
        try {
            await this.eventStreamHelper.sendEventMessage(this, pbMessage);
        }
        catch (error) {
            console.error('Error sending event message:', error);
            throw error;
        }
    }
    async sendEventStoreMessage(msg) {
        const pbMessage = new pb.kubemq.Event();
        pbMessage.EventID = msg.id || utils_1.Utils.uuid();
        pbMessage.ClientID = msg.clientId || this.clientId;
        pbMessage.Channel = msg.channel;
        pbMessage.Body = typeof msg.body === 'string' ? new TextEncoder().encode(msg.body) : msg.body;
        pbMessage.Metadata = msg.metadata;
        if (msg.tags != null) {
            pbMessage.Tags = msg.tags;
        }
        pbMessage.Store = true;
        try {
            return await this.eventStreamHelper.sendEventStoreMessage(this, pbMessage);
        }
        catch (error) {
            console.error('Error sending event store message:', error);
            throw error;
        }
    }
    // Subscribe to Events Method
    async subscribeToEvents(request) {
        try {
            console.debug('Subscribing to event');
            request.validate(); // Validate the request
            const subscribe = request.encode(this);
            const stream = this.grpcClient.SubscribeToEvents(subscribe, this.getMetadata());
            // Assign observer to the request
            request.observer = stream;
            // Event received
            stream.on('data', (data) => {
                console.debug(`Event received: ID='${data.EventID}', Channel='${data.Channel}'`);
                const event = eventTypes_1.EventMessageReceived.decode(data);
                request.raiseOnReceiveMessage(event); // Process received event
            });
            // Handle errors (like server being unavailable)
            stream.on('error', (err) => {
                console.error('Event Subscription error:', err.message);
                console.error('Event Subscription error code:', err.code);
                request.raiseOnError(err.message);
                if (err.code === grpc.status.UNAVAILABLE) {
                    console.debug('Server is unavailable, attempting to reconnect...');
                    request.reconnect(this, this.reconnectIntervalSeconds); // Trigger reconnection
                }
            });
            // Handle stream close
            stream.on('close', () => {
                console.debug('Stream closed by the server, attempting to reconnect...');
                request.reconnect(this, this.reconnectIntervalSeconds); // Attempt to reconnect when the stream is closed
            });
        }
        catch (error) {
            console.error('Failed to subscribe to events', error);
            throw new Error('Event Subscription failed');
        }
    }
    // Subscribe to EventStore Method
    async subscribeToEventsStore(request) {
        try {
            console.debug('Subscribing to eventstore');
            request.validate(); // Validate the request
            const subscribe = request.encode(this);
            //console.log(subscribe.toObject());
            const stream = this.grpcClient.SubscribeToEvents(subscribe, this.getMetadata());
            // Assign observer to the request
            request.observer = stream;
            // Event received
            stream.on('data', (data) => {
                console.debug(`EventStore Event received: ID='${data.EventID}', Channel='${data.Channel}'`);
                const event = eventTypes_1.EventStoreMessageReceived.decode(data);
                request.raiseOnReceiveMessage(event); // Process received event
            });
            // Handle errors (like server being unavailable)
            stream.on('error', (err) => {
                console.error('EventStore Subscription error:', err.message);
                console.error('EventStore Subscription error code:', err.code);
                request.raiseOnError(err.message);
                if (err.code === grpc.status.UNAVAILABLE) {
                    console.debug('Server is unavailable, attempting to reconnect...');
                    request.reconnect(this, this.reconnectIntervalSeconds); // Trigger reconnection
                }
            });
            // Handle stream close
            stream.on('close', () => {
                console.debug('Stream closed by the server, attempting to reconnect...');
                request.reconnect(this, this.reconnectIntervalSeconds); // Attempt to reconnect when the stream is closed
            });
        }
        catch (error) {
            console.error('Failed to subscribe to eventstore', error);
            throw new Error('EventStore Subscription failed');
        }
    }
    /**
      * Create channel
      * @param channelName
      * @return Promise<void>
      */
    createEventsChannel(channelName) {
        return (0, common_1.createChannel)(this.grpcClient, this.getMetadata(), this.clientId, channelName, 'events');
    }
    /**
    * Create events store channel
    * @param channelName
    * @return Promise<void>
    */
    createEventsStoreChannel(channelName) {
        return (0, common_1.createChannel)(this.grpcClient, this.getMetadata(), this.clientId, channelName, 'events_store');
    }
    /**
     * Delete commands channel
     * @param channelName
     * @return Promise<void>
     */
    deleteEventsChannel(channelName) {
        return (0, common_1.deleteChannel)(this.grpcClient, this.getMetadata(), this.clientId, channelName, 'events');
    }
    /**
     * Delete events store channel
     * @param channelName
     * @return Promise<void>
     */
    deleteEventsStoreChannel(channelName) {
        return (0, common_1.deleteChannel)(this.grpcClient, this.getMetadata(), this.clientId, channelName, 'events_store');
    }
    /**
     * List events channels
     * @param search
     * @return Promise<PubSubChannel[]>
     */
    listEventsChannels(search) {
        return (0, common_1.listPubSubChannels)(this.grpcClient, this.getMetadata(), this.clientId, search, 'events');
    }
    /**
     * List events store channels
     * @param search
     * @return Promise<PubSubChannel[]>
     */
    listEventsStoreChannels(search) {
        return (0, common_1.listPubSubChannels)(this.grpcClient, this.getMetadata(), this.clientId, search, 'events_store');
    }
}
exports.PubsubClient = PubsubClient;
//# sourceMappingURL=PubsubClient.js.map
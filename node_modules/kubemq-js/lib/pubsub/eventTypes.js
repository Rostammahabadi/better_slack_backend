"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventsStoreSubscriptionRequest = exports.EventStoreMessageReceived = exports.EventsSubscriptionRequest = exports.EventsSendResult = exports.EventMessageReceived = exports.EventStoreType = void 0;
const pb = require("../protos");
var EventStoreType;
(function (EventStoreType) {
    EventStoreType[EventStoreType["EventsStoreTypeUndefined"] = 0] = "EventsStoreTypeUndefined";
    EventStoreType[EventStoreType["StartNewOnly"] = 1] = "StartNewOnly";
    EventStoreType[EventStoreType["StartFromFirst"] = 2] = "StartFromFirst";
    EventStoreType[EventStoreType["StartFromLast"] = 3] = "StartFromLast";
    EventStoreType[EventStoreType["StartAtSequence"] = 4] = "StartAtSequence";
    EventStoreType[EventStoreType["StartAtTime"] = 5] = "StartAtTime";
    EventStoreType[EventStoreType["StartAtTimeDelta"] = 6] = "StartAtTimeDelta";
})(EventStoreType || (exports.EventStoreType = EventStoreType = {}));
class EventMessageReceived {
    /**
     * Constructor to initialize the fields.
     */
    constructor() {
        this.id = '';
        this.fromClientId = '';
        this.timestamp = new Date();
        this.channel = '';
        this.metadata = '';
        this.body = new Uint8Array();
        this.tags = new Map();
    }
    /**
     * Decodes a KubeMQ EventReceive object into an EventMessageReceived instance.
     *
     * @param event The EventReceive object to decode.
     * @return The decoded EventMessageReceived instance.
     */
    static decode(event) {
        const message = new EventMessageReceived();
        message.id = event.EventID;
        message.fromClientId = event.Tags.get("x-kubemq-client-id") || '';
        message.channel = event.Channel;
        message.metadata = event.Metadata;
        message.body = typeof event.Body === 'string' ? new TextEncoder().encode(event.Body) : event.Body;
        message.tags = event.Tags;
        return message;
    }
}
exports.EventMessageReceived = EventMessageReceived;
class EventsSendResult {
    constructor(id = '', sent = false, error = '') {
        this.id = id;
        this.sent = sent;
        this.error = error;
    }
    /**
     * Decodes a KubeMQ Result object into an EventSendResult instance.
     *
     * @param result The KubeMQ Result object to decode.
     * @returns The decoded EventSendResult instance.
     */
    static decode(result) {
        return new EventsSendResult(result.EventID, result.Sent, result.Error);
    }
    /**
     * Returns a string representation of the event send result.
     *
     * @returns A string containing the event send result details.
     */
    toString() {
        return `EventSendResult: id=${this.id}, sent=${this.sent}, error=${this.error}`;
    }
}
exports.EventsSendResult = EventsSendResult;
class EventsSubscriptionRequest {
    constructor(channel, group) {
        this.isReconnecting = false; // Flag to track reconnection status
        this.channel = channel;
        this.group = group;
    }
    validate() {
        if (!this.channel || !this.onReceiveEventCallback) {
            throw new Error('Event subscription must have a channel and onReceiveEventCallback.');
        }
    }
    encode(pubSubClient) {
        const subscribe = new pb.kubemq.Subscribe();
        subscribe.ClientID = pubSubClient.clientId;
        subscribe.Channel = this.channel;
        subscribe.Group = this.group || '';
        subscribe.SubscribeTypeData = pb.kubemq.Subscribe.SubscribeType.Events;
        return subscribe;
    }
    raiseOnReceiveMessage(event) {
        if (this.onReceiveEventCallback) {
            this.onReceiveEventCallback(event);
        }
    }
    raiseOnError(errorMsg) {
        if (this.onErrorCallback) {
            this.onErrorCallback(errorMsg);
        }
    }
    cancel() {
        if (this.observer) {
            this.observer.cancel();
            console.debug('Subscription cancelled');
        }
    }
    reconnect(pubSubClient, reconnectIntervalSeconds) {
        if (this.isReconnecting) {
            console.debug('Already reconnecting, skipping duplicate reconnection attempt');
            return;
        }
        this.isReconnecting = true;
        console.debug('Reconnection attempt will start after', reconnectIntervalSeconds, 'seconds');
        setTimeout(async () => {
            console.debug('Attempting to re-subscribe...');
            try {
                this.cancel(); // Cancel any existing subscription before re-subscribing
                await pubSubClient.subscribeToEvents(this);
                console.debug('Re-subscribed successfully');
                this.isReconnecting = false; // Reset the flag on successful reconnection
            }
            catch (error) {
                console.error('Re-subscribe attempt failed', error);
                this.isReconnecting = false; // Reset the flag on failure
            }
        }, reconnectIntervalSeconds * 1000);
    }
}
exports.EventsSubscriptionRequest = EventsSubscriptionRequest;
class EventStoreMessageReceived {
    /**
     * Constructor to initialize the fields.
     */
    constructor() {
        this.id = '';
        this.fromClientId = '';
        this.timestamp = new Date();
        this.channel = '';
        this.metadata = '';
        this.body = new Uint8Array();
        this.tags = new Map();
        this.sequence = 0;
    }
    /**
     * Decodes a KubeMQ EventReceive object into an EventMessageReceived instance.
     *
     * @param event The EventReceive object to decode.
     * @return The decoded EventMessageReceived instance.
     */
    static decode(event) {
        const message = new EventStoreMessageReceived();
        message.id = event.EventID;
        message.fromClientId = event.Tags.get("x-kubemq-client-id") || '';
        message.channel = event.Channel;
        message.metadata = event.Metadata;
        message.body = typeof event.Body === 'string' ? new TextEncoder().encode(event.Body) : event.Body;
        message.tags = event.Tags;
        message.sequence = event.Sequence;
        return message;
    }
}
exports.EventStoreMessageReceived = EventStoreMessageReceived;
class EventsStoreSubscriptionRequest {
    constructor(channel, group) {
        this.isReconnecting = false; // Flag to track reconnection status
        this.channel = channel;
        this.group = group;
    }
    validate() {
        if (!this.channel || this.channel.trim().length === 0) {
            throw new Error("Event Store subscription must have a channel.");
        }
        if (!this.onReceiveEventCallback) {
            throw new Error("Event Store subscription must have an onReceiveEventCallback function.");
        }
        if (this.eventsStoreType == null || this.eventsStoreType === EventStoreType.EventsStoreTypeUndefined) {
            throw new Error("Event Store subscription must have an events store type.");
        }
        if (this.eventsStoreType === EventStoreType.StartAtSequence && !this.eventsStoreSequenceValue) {
            throw new Error("Event Store subscription with StartAtSequence events store type must have a sequence value.");
        }
        if (this.eventsStoreType === EventStoreType.StartAtTime && !this.eventsStoreStartTime) {
            throw new Error("Event Store subscription with StartAtTime events store type must have a start time.");
        }
    }
    encode(pubSubClient) {
        const subscribe = new pb.kubemq.Subscribe();
        subscribe.ClientID = pubSubClient.clientId;
        subscribe.Channel = this.channel;
        subscribe.Group = this.group || '';
        subscribe.SubscribeTypeData = pb.kubemq.Subscribe.SubscribeType.EventsStore;
        subscribe.EventsStoreTypeData = this.convertToEventStoreType(this.eventsStoreType);
        subscribe.EventsStoreTypeValue = this.eventsStoreStartTime !== null && this.eventsStoreStartTime !== undefined ? Math.floor(this.eventsStoreStartTime.getTime() / 1000) : this.eventsStoreSequenceValue;
        return subscribe;
    }
    convertToEventStoreType(eventsStoreType) {
        return eventsStoreType;
    }
    raiseOnReceiveMessage(event) {
        if (this.onReceiveEventCallback) {
            this.onReceiveEventCallback(event);
        }
    }
    raiseOnError(errorMsg) {
        if (this.onErrorCallback) {
            this.onErrorCallback(errorMsg);
        }
    }
    cancel() {
        if (this.observer) {
            this.observer.cancel();
            console.debug('Subscription cancelled');
        }
    }
    reconnect(pubSubClient, reconnectIntervalSeconds) {
        if (this.isReconnecting) {
            console.debug('Already reconnecting, skipping duplicate reconnection attempt');
            return;
        }
        this.isReconnecting = true;
        console.debug('Reconnection attempt will start after', reconnectIntervalSeconds, 'seconds');
        setTimeout(async () => {
            console.debug('Attempting to re-subscribe...');
            try {
                this.cancel(); // Cancel any existing subscription before re-subscribing
                await pubSubClient.subscribeToEventsStore(this);
                console.debug('Re-subscribed successfully');
                this.isReconnecting = false; // Reset the flag on successful reconnection
            }
            catch (error) {
                console.error('Re-subscribe attempt failed', error);
                this.isReconnecting = false; // Reset the flag on failure
            }
        }, reconnectIntervalSeconds * 1000);
    }
}
exports.EventsStoreSubscriptionRequest = EventsStoreSubscriptionRequest;
//# sourceMappingURL=eventTypes.js.map
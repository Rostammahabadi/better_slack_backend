"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedEvent = exports.KubeMQClient = void 0;
const grpc = require("@grpc/grpc-js");
const fs = require("fs");
const kubemq = require("../protos");
/**
 * KubeMQClient - Client for communicating with a KubeMQ server using gRPC.
 * Supports plain and TLS (Transport Layer Security) connections.
 */
class KubeMQClient {
    constructor(config) {
        this.address = config.address || 'localhost:50000';
        this.clientId = config.clientId || '';
        this.authToken = config.authToken;
        this.tls = config.tls || false;
        this.tlsCertFile = config.tlsCertFile;
        this.tlsKeyFile = config.tlsKeyFile;
        this.tlsCaCertFile = config.tlsCaCertFile;
        this.maxReceiveSize = config.maxReceiveSize || 1024 * 1024 * 100; // 100MB
        this.reconnectIntervalSeconds = config.reconnectIntervalSeconds || 1; // 1 second
        this.logLevel = config.logLevel || 'INFO';
        this.metadata = new grpc.Metadata();
        if (this.authToken) {
            this.metadata.add('authorization', this.authToken);
        }
        this.init();
    }
    init() {
        let channelCredentials;
        if (this.tls) {
            // Validate that TLS file paths are provided
            if (!this.tlsCertFile || !this.tlsKeyFile) {
                throw new Error('TLS is enabled, but tlsCertFile or tlsKeyFile is missing in the configuration.');
            }
            // Read TLS files
            const certChain = fs.readFileSync(this.tlsCertFile);
            const privateKey = fs.readFileSync(this.tlsKeyFile);
            let rootCerts = null;
            if (this.tlsCaCertFile) {
                rootCerts = fs.readFileSync(this.tlsCaCertFile);
            }
            // Create SSL credentials
            channelCredentials = grpc.credentials.createSsl(rootCerts, privateKey, certChain);
        }
        else {
            // Use insecure credentials for non-TLS connections
            channelCredentials = grpc.credentials.createInsecure();
        }
        const channelOptions = {
            'grpc.max_receive_message_length': this.maxReceiveSize,
            // Additional channel options can be added here
        };
        this.grpcClient = new kubemq.kubemq.kubemqClient(this.address, channelCredentials, channelOptions);
    }
    callOptions() {
        return {
            deadline: new Date(Date.now() + 30000),
        };
    }
    ping() {
        return new Promise((resolve, reject) => {
            this.grpcClient.ping(new kubemq.kubemq.Empty(), (error, response) => {
                if (error)
                    return reject(error);
                resolve({
                    host: response.getHost(),
                    version: response.getVersion(),
                    serverStartTime: response.getServerstarttime(),
                    serverUpTimeSeconds: response.getServeruptimeseconds(),
                });
            });
        });
    }
    close() {
        this.grpcClient.close();
    }
    getMetadata() {
        return this.metadata;
    }
}
exports.KubeMQClient = KubeMQClient;
/** passes through events as they happen. You will not get events from before you start listening */
class TypedEvent {
    constructor() {
        this.listeners = [];
        this.listenersOncer = [];
        this.on = (listener) => {
            this.listeners.push(listener);
            return {
                dispose: () => this.off(listener),
            };
        };
        this.once = (listener) => {
            this.listenersOncer.push(listener);
        };
        this.off = (listener) => {
            const callbackIndex = this.listeners.indexOf(listener);
            if (callbackIndex > -1)
                this.listeners.splice(callbackIndex, 1);
        };
        this.emit = (event) => {
            /** Update any general listeners */
            this.listeners.forEach((listener) => listener(event));
            /** Clear the `once` queue */
            if (this.listenersOncer.length > 0) {
                const toCall = this.listenersOncer;
                this.listenersOncer = [];
                toCall.forEach((listener) => listener(event));
            }
        };
        this.pipe = (te) => {
            return this.on((e) => te.emit(e));
        };
    }
}
exports.TypedEvent = TypedEvent;
//# sourceMappingURL=KubeMQClient.js.map
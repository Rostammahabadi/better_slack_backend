"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsSubscriptionRequest = exports.CommandMessageReceived = void 0;
const pb = require("../protos");
class CommandMessageReceived {
    /**
     * Constructor to initialize the fields.
     */
    constructor() {
        this.id = '';
        this.fromClientId = '';
        this.timestamp = new Date();
        this.channel = '';
        this.metadata = '';
        this.body = new Uint8Array();
        this.replyChannel = '';
        this.tags = new Map();
    }
    /**
     * Decodes a protocol buffer request into a CommandMessageReceived instance.
     *
     * @param commandReceive The protocol buffer request to decode.
     * @return The decoded CommandMessageReceived instance.
     */
    static decode(commandReceive) {
        const message = new CommandMessageReceived();
        message.id = commandReceive.RequestID;
        message.fromClientId = commandReceive.ClientID;
        message.channel = commandReceive.Channel;
        message.metadata = commandReceive.Metadata;
        message.body = typeof commandReceive.Body === 'string'
            ? new TextEncoder().encode(commandReceive.Body)
            : commandReceive.Body;
        message.replyChannel = commandReceive.ReplyChannel;
        message.tags = commandReceive.Tags;
        return message;
    }
}
exports.CommandMessageReceived = CommandMessageReceived;
class CommandsSubscriptionRequest {
    constructor(channel, group) {
        this.isReconnecting = false; // Flag to track reconnection status
        this.channel = channel;
        this.group = group;
    }
    validate() {
        if (!this.channel || !this.onReceiveEventCallback) {
            throw new Error('Event subscription must have a channel and onReceiveEventCallback.');
        }
    }
    encode(cqClient) {
        const subscribe = new pb.kubemq.Subscribe();
        subscribe.ClientID = cqClient.clientId;
        subscribe.Channel = this.channel;
        subscribe.Group = this.group || '';
        subscribe.SubscribeTypeData = pb.kubemq.Subscribe.SubscribeType.Commands;
        return subscribe;
    }
    raiseOnReceiveMessage(event) {
        if (this.onReceiveEventCallback) {
            this.onReceiveEventCallback(event);
        }
    }
    raiseOnError(errorMsg) {
        if (this.onErrorCallback) {
            this.onErrorCallback(errorMsg);
        }
    }
    cancel() {
        if (this.observer) {
            this.observer.cancel();
            console.debug('Subscription cancelled');
        }
    }
    reconnect(cqClient, reconnectIntervalSeconds) {
        if (this.isReconnecting) {
            console.debug('Already reconnecting, skipping duplicate reconnection attempt');
            return;
        }
        this.isReconnecting = true;
        console.debug('Reconnection attempt will start after', reconnectIntervalSeconds, 'seconds');
        setTimeout(async () => {
            console.debug('Attempting to re-subscribe...');
            try {
                this.cancel(); // Cancel any existing subscription before re-subscribing
                await cqClient.subscribeToCommands(this);
                console.debug('Re-subscribed successfully');
                this.isReconnecting = false; // Reset the flag on successful reconnection
            }
            catch (error) {
                console.error('Re-subscribe attempt failed', error);
                this.isReconnecting = false; // Reset the flag on failure
            }
        }, reconnectIntervalSeconds * 1000);
    }
}
exports.CommandsSubscriptionRequest = CommandsSubscriptionRequest;
//# sourceMappingURL=commandTypes.js.map
"use strict";
// src/cq/queryTypes.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueriesSubscriptionRequest = exports.QueryMessageReceived = void 0;
const pb = require("../protos");
class QueryMessageReceived {
    /**
     * Constructor to initialize the fields with default values.
     */
    constructor() {
        this.id = '';
        this.fromClientId = '';
        this.timestamp = new Date();
        this.channel = '';
        this.metadata = '';
        this.body = new Uint8Array();
        this.replyChannel = '';
        this.tags = new Map();
    }
    /**
     * Decodes a protocol buffer request into a QueryMessageReceived instance.
     *
     * @param queryReceive The protocol buffer request to decode.
     * @return The decoded QueryMessageReceived instance.
     */
    static decode(queryReceive) {
        const message = new QueryMessageReceived();
        message.id = queryReceive.RequestID;
        message.fromClientId = queryReceive.ClientID;
        message.timestamp = new Date(); // Instant.now() equivalent
        message.channel = queryReceive.Channel;
        message.metadata = queryReceive.Metadata;
        message.body = typeof queryReceive.Body === 'string'
            ? new TextEncoder().encode(queryReceive.Body)
            : queryReceive.Body;
        message.replyChannel = queryReceive.ReplyChannel;
        message.tags = queryReceive.Tags;
        return message;
    }
}
exports.QueryMessageReceived = QueryMessageReceived;
class QueriesSubscriptionRequest {
    constructor(channel, group) {
        this.isReconnecting = false; // Flag to track reconnection status
        this.channel = channel;
        this.group = group;
    }
    validate() {
        if (!this.channel || !this.onReceiveEventCallback) {
            throw new Error('Event subscription must have a channel and onReceiveEventCallback.');
        }
    }
    encode(cqClient) {
        const subscribe = new pb.kubemq.Subscribe();
        subscribe.ClientID = cqClient.clientId;
        subscribe.Channel = this.channel;
        subscribe.Group = this.group || '';
        subscribe.SubscribeTypeData = pb.kubemq.Subscribe.SubscribeType.Queries;
        return subscribe;
    }
    raiseOnReceiveMessage(event) {
        if (this.onReceiveEventCallback) {
            this.onReceiveEventCallback(event);
        }
    }
    raiseOnError(errorMsg) {
        if (this.onErrorCallback) {
            this.onErrorCallback(errorMsg);
        }
    }
    cancel() {
        if (this.observer) {
            this.observer.cancel();
            console.debug('Subscription cancelled');
        }
    }
    reconnect(cqClient, reconnectIntervalSeconds) {
        if (this.isReconnecting) {
            console.debug('Already reconnecting, skipping duplicate reconnection attempt');
            return;
        }
        this.isReconnecting = true;
        console.debug('Reconnection attempt will start after', reconnectIntervalSeconds, 'seconds');
        setTimeout(async () => {
            console.debug('Attempting to re-subscribe...');
            try {
                this.cancel(); // Cancel any existing subscription before re-subscribing
                await cqClient.subscribeToCommands(this);
                console.debug('Re-subscribed successfully');
                this.isReconnecting = false; // Reset the flag on successful reconnection
            }
            catch (error) {
                console.error('Re-subscribe attempt failed', error);
                this.isReconnecting = false; // Reset the flag on failure
            }
        }, reconnectIntervalSeconds * 1000);
    }
}
exports.QueriesSubscriptionRequest = QueriesSubscriptionRequest;
//# sourceMappingURL=queryTypes.js.map
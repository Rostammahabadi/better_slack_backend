"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createChannel = createChannel;
exports.deleteChannel = deleteChannel;
exports.listPubSubChannels = listPubSubChannels;
exports.listQueuesChannels = listQueuesChannels;
exports.listCQChannels = listCQChannels;
const pb = require("../protos");
const utils_1 = require("./utils");
function createChannel(client, md, clientId, channelName, channelType) {
    const pbMessage = new pb.kubemq.Request();
    pbMessage.RequestID = (utils_1.Utils.uuid());
    pbMessage.ClientID = (clientId);
    pbMessage.RequestTypeData = (2);
    pbMessage.Channel = ('kubemq.cluster.internal.requests');
    pbMessage.Metadata = ('create-channel');
    const pbtags = pbMessage.Tags;
    pbtags.set('channel_type', channelType);
    pbtags.set('channel', channelName);
    pbtags.set('client_id', clientId);
    pbMessage.Timeout = (10000);
    return new Promise((resolve, reject) => {
        client.SendRequest(pbMessage, md, (e) => {
            if (e) {
                reject(e);
                return;
            }
            resolve();
        });
    });
}
function deleteChannel(client, md, clientId, channelName, channelType) {
    const pbMessage = new pb.kubemq.Request();
    pbMessage.RequestID = (utils_1.Utils.uuid());
    pbMessage.ClientID = (clientId);
    pbMessage.RequestTypeData = (2);
    pbMessage.Channel = ('kubemq.cluster.internal.requests');
    pbMessage.Metadata = ('delete-channel');
    const pbtags = pbMessage.Tags;
    pbtags.set('channel_type', channelType);
    pbtags.set('channel', channelName);
    pbtags.set('client_id', clientId);
    pbMessage.Timeout = (10000);
    return new Promise((resolve, reject) => {
        client.SendRequest(pbMessage, md, (e) => {
            if (e) {
                reject(e);
                return;
            }
            resolve();
        });
    });
}
function listPubSubChannels(client, md, clientId, search, channelType) {
    const pbMessage = new pb.kubemq.Request();
    pbMessage.RequestID = (utils_1.Utils.uuid());
    pbMessage.ClientID = (clientId);
    pbMessage.RequestTypeData = (2);
    pbMessage.Channel = ('kubemq.cluster.internal.requests');
    pbMessage.Metadata = ('list-channels');
    const pbtags = pbMessage.Tags;
    pbtags.set('client_id', clientId);
    pbtags.set('channel_type', channelType);
    pbtags.set('channel_search', search);
    pbMessage.Timeout = (10000);
    return new Promise((resolve, reject) => {
        client.SendRequest(pbMessage, md, (e, data) => {
            if (e) {
                reject(e);
                return;
            }
            if (!data) {
                reject(new Error('no data'));
                return;
            }
            if (data.Body === null) {
                resolve([]);
                return;
            }
            const channels = decodePubSubChannelList(data.Body);
            resolve(channels);
        });
    });
}
function listQueuesChannels(client, md, clientId, search, channelType) {
    const pbMessage = new pb.kubemq.Request();
    pbMessage.RequestID = (utils_1.Utils.uuid());
    pbMessage.ClientID = (clientId);
    pbMessage.RequestTypeData = (2);
    pbMessage.Channel = ('kubemq.cluster.internal.requests');
    pbMessage.Metadata = ('list-channels');
    const pbtags = pbMessage.Tags;
    pbtags.set('client_id', clientId);
    pbtags.set('channel_type', channelType);
    pbtags.set('channel_search', search);
    pbMessage.Timeout = (10000);
    return new Promise((resolve, reject) => {
        client.SendRequest(pbMessage, md, (e, data) => {
            if (e) {
                reject(e);
                return;
            }
            if (!data) {
                reject(new Error('no data'));
                return;
            }
            if (data.Body === null) {
                resolve([]);
                return;
            }
            const channels = decodeQueuesChannelList(data.Body);
            resolve(channels);
        });
    });
}
function listCQChannels(client, md, clientId, search, channelType) {
    const pbMessage = new pb.kubemq.Request();
    pbMessage.RequestID = (utils_1.Utils.uuid());
    pbMessage.ClientID = (clientId);
    pbMessage.RequestTypeData = (2);
    pbMessage.Channel = ('kubemq.cluster.internal.requests');
    pbMessage.Metadata = ('list-channels');
    const pbtags = pbMessage.Tags;
    pbtags.set('client_id', clientId);
    pbtags.set('channel_type', channelType);
    pbtags.set('channel_search', search);
    pbMessage.Timeout = (10000);
    return new Promise((resolve, reject) => {
        client.SendRequest(pbMessage, md, (e, data) => {
            if (e) {
                reject(e);
                return;
            }
            if (!data) {
                reject(new Error('no data'));
                return;
            }
            if (data.Body === null) {
                resolve([]);
                return;
            }
            const channels = decodeCQChannelList(data.Body);
            resolve(channels);
        });
    });
}
function decodePubSubChannelList(dataBytes) {
    /**
     * Decodes the given data bytes into a list of PubSubChannel objects.
     *
     * @param dataBytes The data bytes to decode.
     * @returns A list of PubSubChannel objects.
     */
    // Decode bytes to string and parse JSON
    const dataStr = new TextDecoder().decode(dataBytes);
    const channelsData = JSON.parse(dataStr);
    const channels = [];
    for (const item of channelsData) {
        // Extracting incoming and outgoing as Stats objects
        const incoming = item['incoming'];
        const outgoing = item['outgoing'];
        // Creating a Channel instance with the Stats objects
        const channel = {
            name: item['name'],
            type: item['type'],
            lastActivity: item['lastActivity'],
            isActive: item['isActive'],
            incoming,
            outgoing,
        };
        channels.push(channel);
    }
    return channels;
}
function decodeQueuesChannelList(dataBytes) {
    /**
     * Decodes a byte string into a list of QueuesChannel objects.
     *
     * @param dataBytes The byte string to be decoded.
     * @returns A list of QueuesChannel objects.
     *
     * Note:
     * - This method assumes that the byte string is encoded in 'utf-8' format.
     * - The byte string should represent a valid JSON object.
     * - The JSON object should contain the necessary fields ('name', 'type', 'lastActivity', 'isActive', 'incoming', 'outgoing') for creating QueuesChannel objects.
     * - The 'incoming' and 'outgoing' fields should contain valid JSON objects that can be parsed into QueuesStats objects.
     */
    // Decode bytes to string and parse JSON
    const dataStr = new TextDecoder().decode(dataBytes);
    const channelsData = JSON.parse(dataStr);
    const channels = [];
    for (const item of channelsData) {
        // Extracting incoming and outgoing as Stats objects
        const incoming = item['incoming'];
        const outgoing = item['outgoing'];
        // Creating a Channel instance with the Stats objects
        const channel = {
            name: item['name'],
            type: item['type'],
            lastActivity: item['lastActivity'],
            isActive: item['isActive'],
            incoming,
            outgoing,
        };
        channels.push(channel);
    }
    return channels;
}
function decodeCQChannelList(dataBytes) {
    /**
     * Decodes the given byte array into a list of CQChannel objects.
     *
     * @param dataBytes The byte array to decode.
     * @returns The list of CQChannel objects decoded from the byte array.
     */
    // Decode bytes to string and parse JSON
    const dataStr = new TextDecoder().decode(dataBytes);
    const channelsData = JSON.parse(dataStr);
    const channels = [];
    for (const item of channelsData) {
        // Extracting incoming and outgoing as Stats objects
        const incoming = item['incoming'];
        const outgoing = item['outgoing'];
        // Creating a Channel instance with the Stats objects
        const channel = {
            name: item['name'],
            type: item['type'],
            lastActivity: item['lastActivity'],
            isActive: item['isActive'],
            incoming,
            outgoing,
        };
        channels.push(channel);
    }
    return channels;
}
//# sourceMappingURL=common.js.map
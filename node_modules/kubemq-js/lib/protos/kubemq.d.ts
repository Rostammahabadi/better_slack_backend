/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.27.3
 * source: kubemq.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export declare namespace kubemq {
    export enum StreamRequestType {
        StreamRequestTypeUnknown = 0,
        ReceiveMessage = 1,
        AckMessage = 2,
        RejectMessage = 3,
        ModifyVisibility = 4,
        ResendMessage = 5,
        SendModifiedMessage = 6
    }
    export enum QueuesDownstreamRequestType {
        PollRequestTypeUnknown = 0,
        Get = 1,
        AckAll = 2,
        AckRange = 3,
        NAckAll = 4,
        NAckRange = 5,
        ReQueueAll = 6,
        ReQueueRange = 7,
        ActiveOffsets = 8,
        TransactionStatus = 9,
        CloseByClient = 10,
        CloseByServer = 11
    }
    export class PingResult extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            Host?: string;
            Version?: string;
            ServerStartTime?: number;
            ServerUpTimeSeconds?: number;
        });
        get Host(): string;
        set Host(value: string);
        get Version(): string;
        set Version(value: string);
        get ServerStartTime(): number;
        set ServerStartTime(value: number);
        get ServerUpTimeSeconds(): number;
        set ServerUpTimeSeconds(value: number);
        static fromObject(data: {
            Host?: string;
            Version?: string;
            ServerStartTime?: number;
            ServerUpTimeSeconds?: number;
        }): PingResult;
        toObject(): {
            Host?: string;
            Version?: string;
            ServerStartTime?: number;
            ServerUpTimeSeconds?: number;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PingResult;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): PingResult;
    }
    export class Empty extends pb_1.Message {
        #private;
        constructor(data?: any[] | {});
        static fromObject(data: {}): Empty;
        toObject(): {};
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Empty;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): Empty;
    }
    export class Result extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            EventID?: string;
            Sent?: boolean;
            Error?: string;
        });
        get EventID(): string;
        set EventID(value: string);
        get Sent(): boolean;
        set Sent(value: boolean);
        get Error(): string;
        set Error(value: string);
        static fromObject(data: {
            EventID?: string;
            Sent?: boolean;
            Error?: string;
        }): Result;
        toObject(): {
            EventID?: string;
            Sent?: boolean;
            Error?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Result;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): Result;
    }
    export class Event extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            EventID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Store?: boolean;
            Tags?: Map<string, string>;
        });
        get EventID(): string;
        set EventID(value: string);
        get ClientID(): string;
        set ClientID(value: string);
        get Channel(): string;
        set Channel(value: string);
        get Metadata(): string;
        set Metadata(value: string);
        get Body(): Uint8Array;
        set Body(value: Uint8Array);
        get Store(): boolean;
        set Store(value: boolean);
        get Tags(): Map<string, string>;
        set Tags(value: Map<string, string>);
        static fromObject(data: {
            EventID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Store?: boolean;
            Tags?: {
                [key: string]: string;
            };
        }): Event;
        toObject(): {
            EventID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Store?: boolean;
            Tags?: {
                [key: string]: string;
            };
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Event;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): Event;
    }
    export class EventReceive extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            EventID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Timestamp?: number;
            Sequence?: number;
            Tags?: Map<string, string>;
        });
        get EventID(): string;
        set EventID(value: string);
        get Channel(): string;
        set Channel(value: string);
        get Metadata(): string;
        set Metadata(value: string);
        get Body(): Uint8Array;
        set Body(value: Uint8Array);
        get Timestamp(): number;
        set Timestamp(value: number);
        get Sequence(): number;
        set Sequence(value: number);
        get Tags(): Map<string, string>;
        set Tags(value: Map<string, string>);
        static fromObject(data: {
            EventID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Timestamp?: number;
            Sequence?: number;
            Tags?: {
                [key: string]: string;
            };
        }): EventReceive;
        toObject(): {
            EventID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Timestamp?: number;
            Sequence?: number;
            Tags?: {
                [key: string]: string;
            };
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventReceive;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): EventReceive;
    }
    export class Subscribe extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            SubscribeTypeData?: Subscribe.SubscribeType;
            ClientID?: string;
            Channel?: string;
            Group?: string;
            EventsStoreTypeData?: Subscribe.EventsStoreType;
            EventsStoreTypeValue?: number;
        });
        get SubscribeTypeData(): Subscribe.SubscribeType;
        set SubscribeTypeData(value: Subscribe.SubscribeType);
        get ClientID(): string;
        set ClientID(value: string);
        get Channel(): string;
        set Channel(value: string);
        get Group(): string;
        set Group(value: string);
        get EventsStoreTypeData(): Subscribe.EventsStoreType;
        set EventsStoreTypeData(value: Subscribe.EventsStoreType);
        get EventsStoreTypeValue(): number;
        set EventsStoreTypeValue(value: number);
        static fromObject(data: {
            SubscribeTypeData?: Subscribe.SubscribeType;
            ClientID?: string;
            Channel?: string;
            Group?: string;
            EventsStoreTypeData?: Subscribe.EventsStoreType;
            EventsStoreTypeValue?: number;
        }): Subscribe;
        toObject(): {
            SubscribeTypeData?: Subscribe.SubscribeType;
            ClientID?: string;
            Channel?: string;
            Group?: string;
            EventsStoreTypeData?: Subscribe.EventsStoreType;
            EventsStoreTypeValue?: number;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Subscribe;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): Subscribe;
    }
    export namespace Subscribe {
        enum SubscribeType {
            SubscribeTypeUndefined = 0,
            Events = 1,
            EventsStore = 2,
            Commands = 3,
            Queries = 4
        }
        enum EventsStoreType {
            EventsStoreTypeUndefined = 0,
            StartNewOnly = 1,
            StartFromFirst = 2,
            StartFromLast = 3,
            StartAtSequence = 4,
            StartAtTime = 5,
            StartAtTimeDelta = 6
        }
    }
    export class Request extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            RequestTypeData?: Request.RequestType;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            ReplyChannel?: string;
            Timeout?: number;
            CacheKey?: string;
            CacheTTL?: number;
            Span?: Uint8Array;
            Tags?: Map<string, string>;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get RequestTypeData(): Request.RequestType;
        set RequestTypeData(value: Request.RequestType);
        get ClientID(): string;
        set ClientID(value: string);
        get Channel(): string;
        set Channel(value: string);
        get Metadata(): string;
        set Metadata(value: string);
        get Body(): Uint8Array;
        set Body(value: Uint8Array);
        get ReplyChannel(): string;
        set ReplyChannel(value: string);
        get Timeout(): number;
        set Timeout(value: number);
        get CacheKey(): string;
        set CacheKey(value: string);
        get CacheTTL(): number;
        set CacheTTL(value: number);
        get Span(): Uint8Array;
        set Span(value: Uint8Array);
        get Tags(): Map<string, string>;
        set Tags(value: Map<string, string>);
        static fromObject(data: {
            RequestID?: string;
            RequestTypeData?: Request.RequestType;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            ReplyChannel?: string;
            Timeout?: number;
            CacheKey?: string;
            CacheTTL?: number;
            Span?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
        }): Request;
        toObject(): {
            RequestID?: string;
            RequestTypeData?: Request.RequestType;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            ReplyChannel?: string;
            Timeout?: number;
            CacheKey?: string;
            CacheTTL?: number;
            Span?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Request;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): Request;
    }
    export namespace Request {
        enum RequestType {
            RequestTypeUnknown = 0,
            Command = 1,
            Query = 2
        }
    }
    export class Response extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            ClientID?: string;
            RequestID?: string;
            ReplyChannel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            CacheHit?: boolean;
            Timestamp?: number;
            Executed?: boolean;
            Error?: string;
            Span?: Uint8Array;
            Tags?: Map<string, string>;
        });
        get ClientID(): string;
        set ClientID(value: string);
        get RequestID(): string;
        set RequestID(value: string);
        get ReplyChannel(): string;
        set ReplyChannel(value: string);
        get Metadata(): string;
        set Metadata(value: string);
        get Body(): Uint8Array;
        set Body(value: Uint8Array);
        get CacheHit(): boolean;
        set CacheHit(value: boolean);
        get Timestamp(): number;
        set Timestamp(value: number);
        get Executed(): boolean;
        set Executed(value: boolean);
        get Error(): string;
        set Error(value: string);
        get Span(): Uint8Array;
        set Span(value: Uint8Array);
        get Tags(): Map<string, string>;
        set Tags(value: Map<string, string>);
        static fromObject(data: {
            ClientID?: string;
            RequestID?: string;
            ReplyChannel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            CacheHit?: boolean;
            Timestamp?: number;
            Executed?: boolean;
            Error?: string;
            Span?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
        }): Response;
        toObject(): {
            ClientID?: string;
            RequestID?: string;
            ReplyChannel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            CacheHit?: boolean;
            Timestamp?: number;
            Executed?: boolean;
            Error?: string;
            Span?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Response;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): Response;
    }
    export class QueueMessage extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            MessageID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Tags?: Map<string, string>;
            Attributes?: QueueMessageAttributes;
            Policy?: QueueMessagePolicy;
            Topic?: string;
            Partition?: number;
            PartitionKey?: string;
        });
        get MessageID(): string;
        set MessageID(value: string);
        get ClientID(): string;
        set ClientID(value: string);
        get Channel(): string;
        set Channel(value: string);
        get Metadata(): string;
        set Metadata(value: string);
        get Body(): Uint8Array;
        set Body(value: Uint8Array);
        get Tags(): Map<string, string>;
        set Tags(value: Map<string, string>);
        get Attributes(): QueueMessageAttributes;
        set Attributes(value: QueueMessageAttributes);
        get has_Attributes(): boolean;
        get Policy(): QueueMessagePolicy;
        set Policy(value: QueueMessagePolicy);
        get has_Policy(): boolean;
        get Topic(): string;
        set Topic(value: string);
        get Partition(): number;
        set Partition(value: number);
        get PartitionKey(): string;
        set PartitionKey(value: string);
        static fromObject(data: {
            MessageID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
            Attributes?: ReturnType<typeof QueueMessageAttributes.prototype.toObject>;
            Policy?: ReturnType<typeof QueueMessagePolicy.prototype.toObject>;
            Topic?: string;
            Partition?: number;
            PartitionKey?: string;
        }): QueueMessage;
        toObject(): {
            MessageID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
            Attributes?: ReturnType<typeof QueueMessageAttributes.prototype.toObject>;
            Policy?: ReturnType<typeof QueueMessagePolicy.prototype.toObject>;
            Topic?: string;
            Partition?: number;
            PartitionKey?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessage;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueueMessage;
    }
    export class QueueMessagesBatchRequest extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            BatchID?: string;
            Messages?: QueueMessage[];
        });
        get BatchID(): string;
        set BatchID(value: string);
        get Messages(): QueueMessage[];
        set Messages(value: QueueMessage[]);
        static fromObject(data: {
            BatchID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
        }): QueueMessagesBatchRequest;
        toObject(): {
            BatchID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessagesBatchRequest;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueueMessagesBatchRequest;
    }
    export class QueueMessagesBatchResponse extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            BatchID?: string;
            Results?: SendQueueMessageResult[];
            HaveErrors?: boolean;
        });
        get BatchID(): string;
        set BatchID(value: string);
        get Results(): SendQueueMessageResult[];
        set Results(value: SendQueueMessageResult[]);
        get HaveErrors(): boolean;
        set HaveErrors(value: boolean);
        static fromObject(data: {
            BatchID?: string;
            Results?: ReturnType<typeof SendQueueMessageResult.prototype.toObject>[];
            HaveErrors?: boolean;
        }): QueueMessagesBatchResponse;
        toObject(): {
            BatchID?: string;
            Results?: ReturnType<typeof SendQueueMessageResult.prototype.toObject>[];
            HaveErrors?: boolean;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessagesBatchResponse;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueueMessagesBatchResponse;
    }
    export class QueueMessageAttributes extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            Timestamp?: number;
            Sequence?: number;
            MD5OfBody?: string;
            ReceiveCount?: number;
            ReRouted?: boolean;
            ReRoutedFromQueue?: string;
            ExpirationAt?: number;
            DelayedTo?: number;
        });
        get Timestamp(): number;
        set Timestamp(value: number);
        get Sequence(): number;
        set Sequence(value: number);
        get MD5OfBody(): string;
        set MD5OfBody(value: string);
        get ReceiveCount(): number;
        set ReceiveCount(value: number);
        get ReRouted(): boolean;
        set ReRouted(value: boolean);
        get ReRoutedFromQueue(): string;
        set ReRoutedFromQueue(value: string);
        get ExpirationAt(): number;
        set ExpirationAt(value: number);
        get DelayedTo(): number;
        set DelayedTo(value: number);
        static fromObject(data: {
            Timestamp?: number;
            Sequence?: number;
            MD5OfBody?: string;
            ReceiveCount?: number;
            ReRouted?: boolean;
            ReRoutedFromQueue?: string;
            ExpirationAt?: number;
            DelayedTo?: number;
        }): QueueMessageAttributes;
        toObject(): {
            Timestamp?: number;
            Sequence?: number;
            MD5OfBody?: string;
            ReceiveCount?: number;
            ReRouted?: boolean;
            ReRoutedFromQueue?: string;
            ExpirationAt?: number;
            DelayedTo?: number;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessageAttributes;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueueMessageAttributes;
    }
    export class QueueMessagePolicy extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            ExpirationSeconds?: number;
            DelaySeconds?: number;
            MaxReceiveCount?: number;
            MaxReceiveQueue?: string;
        });
        get ExpirationSeconds(): number;
        set ExpirationSeconds(value: number);
        get DelaySeconds(): number;
        set DelaySeconds(value: number);
        get MaxReceiveCount(): number;
        set MaxReceiveCount(value: number);
        get MaxReceiveQueue(): string;
        set MaxReceiveQueue(value: string);
        static fromObject(data: {
            ExpirationSeconds?: number;
            DelaySeconds?: number;
            MaxReceiveCount?: number;
            MaxReceiveQueue?: string;
        }): QueueMessagePolicy;
        toObject(): {
            ExpirationSeconds?: number;
            DelaySeconds?: number;
            MaxReceiveCount?: number;
            MaxReceiveQueue?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessagePolicy;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueueMessagePolicy;
    }
    export class SendQueueMessageResult extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            MessageID?: string;
            SentAt?: number;
            ExpirationAt?: number;
            DelayedTo?: number;
            IsError?: boolean;
            Error?: string;
            RefChannel?: string;
            RefTopic?: string;
            RefPartition?: number;
            RefHash?: string;
        });
        get MessageID(): string;
        set MessageID(value: string);
        get SentAt(): number;
        set SentAt(value: number);
        get ExpirationAt(): number;
        set ExpirationAt(value: number);
        get DelayedTo(): number;
        set DelayedTo(value: number);
        get IsError(): boolean;
        set IsError(value: boolean);
        get Error(): string;
        set Error(value: string);
        get RefChannel(): string;
        set RefChannel(value: string);
        get RefTopic(): string;
        set RefTopic(value: string);
        get RefPartition(): number;
        set RefPartition(value: number);
        get RefHash(): string;
        set RefHash(value: string);
        static fromObject(data: {
            MessageID?: string;
            SentAt?: number;
            ExpirationAt?: number;
            DelayedTo?: number;
            IsError?: boolean;
            Error?: string;
            RefChannel?: string;
            RefTopic?: string;
            RefPartition?: number;
            RefHash?: string;
        }): SendQueueMessageResult;
        toObject(): {
            MessageID?: string;
            SentAt?: number;
            ExpirationAt?: number;
            DelayedTo?: number;
            IsError?: boolean;
            Error?: string;
            RefChannel?: string;
            RefTopic?: string;
            RefPartition?: number;
            RefHash?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SendQueueMessageResult;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): SendQueueMessageResult;
    }
    export class ReceiveQueueMessagesRequest extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            MaxNumberOfMessages?: number;
            WaitTimeSeconds?: number;
            IsPeak?: boolean;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get ClientID(): string;
        set ClientID(value: string);
        get Channel(): string;
        set Channel(value: string);
        get MaxNumberOfMessages(): number;
        set MaxNumberOfMessages(value: number);
        get WaitTimeSeconds(): number;
        set WaitTimeSeconds(value: number);
        get IsPeak(): boolean;
        set IsPeak(value: boolean);
        static fromObject(data: {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            MaxNumberOfMessages?: number;
            WaitTimeSeconds?: number;
            IsPeak?: boolean;
        }): ReceiveQueueMessagesRequest;
        toObject(): {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            MaxNumberOfMessages?: number;
            WaitTimeSeconds?: number;
            IsPeak?: boolean;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReceiveQueueMessagesRequest;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): ReceiveQueueMessagesRequest;
    }
    export class ReceiveQueueMessagesResponse extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            Messages?: QueueMessage[];
            MessagesReceived?: number;
            MessagesExpired?: number;
            IsPeak?: boolean;
            IsError?: boolean;
            Error?: string;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get Messages(): QueueMessage[];
        set Messages(value: QueueMessage[]);
        get MessagesReceived(): number;
        set MessagesReceived(value: number);
        get MessagesExpired(): number;
        set MessagesExpired(value: number);
        get IsPeak(): boolean;
        set IsPeak(value: boolean);
        get IsError(): boolean;
        set IsError(value: boolean);
        get Error(): string;
        set Error(value: string);
        static fromObject(data: {
            RequestID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
            MessagesReceived?: number;
            MessagesExpired?: number;
            IsPeak?: boolean;
            IsError?: boolean;
            Error?: string;
        }): ReceiveQueueMessagesResponse;
        toObject(): {
            RequestID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
            MessagesReceived?: number;
            MessagesExpired?: number;
            IsPeak?: boolean;
            IsError?: boolean;
            Error?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReceiveQueueMessagesResponse;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): ReceiveQueueMessagesResponse;
    }
    export class AckAllQueueMessagesRequest extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            WaitTimeSeconds?: number;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get ClientID(): string;
        set ClientID(value: string);
        get Channel(): string;
        set Channel(value: string);
        get WaitTimeSeconds(): number;
        set WaitTimeSeconds(value: number);
        static fromObject(data: {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            WaitTimeSeconds?: number;
        }): AckAllQueueMessagesRequest;
        toObject(): {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            WaitTimeSeconds?: number;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AckAllQueueMessagesRequest;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): AckAllQueueMessagesRequest;
    }
    export class AckAllQueueMessagesResponse extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            AffectedMessages?: number;
            IsError?: boolean;
            Error?: string;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get AffectedMessages(): number;
        set AffectedMessages(value: number);
        get IsError(): boolean;
        set IsError(value: boolean);
        get Error(): string;
        set Error(value: string);
        static fromObject(data: {
            RequestID?: string;
            AffectedMessages?: number;
            IsError?: boolean;
            Error?: string;
        }): AckAllQueueMessagesResponse;
        toObject(): {
            RequestID?: string;
            AffectedMessages?: number;
            IsError?: boolean;
            Error?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AckAllQueueMessagesResponse;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): AckAllQueueMessagesResponse;
    }
    export class StreamQueueMessagesRequest extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            ClientID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Channel?: string;
            VisibilitySeconds?: number;
            WaitTimeSeconds?: number;
            RefSequence?: number;
            ModifiedMessage?: QueueMessage;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get ClientID(): string;
        set ClientID(value: string);
        get StreamRequestTypeData(): StreamRequestType;
        set StreamRequestTypeData(value: StreamRequestType);
        get Channel(): string;
        set Channel(value: string);
        get VisibilitySeconds(): number;
        set VisibilitySeconds(value: number);
        get WaitTimeSeconds(): number;
        set WaitTimeSeconds(value: number);
        get RefSequence(): number;
        set RefSequence(value: number);
        get ModifiedMessage(): QueueMessage;
        set ModifiedMessage(value: QueueMessage);
        get has_ModifiedMessage(): boolean;
        static fromObject(data: {
            RequestID?: string;
            ClientID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Channel?: string;
            VisibilitySeconds?: number;
            WaitTimeSeconds?: number;
            RefSequence?: number;
            ModifiedMessage?: ReturnType<typeof QueueMessage.prototype.toObject>;
        }): StreamQueueMessagesRequest;
        toObject(): {
            RequestID?: string;
            ClientID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Channel?: string;
            VisibilitySeconds?: number;
            WaitTimeSeconds?: number;
            RefSequence?: number;
            ModifiedMessage?: ReturnType<typeof QueueMessage.prototype.toObject>;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StreamQueueMessagesRequest;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): StreamQueueMessagesRequest;
    }
    export class StreamQueueMessagesResponse extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Message?: QueueMessage;
            IsError?: boolean;
            Error?: string;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get StreamRequestTypeData(): StreamRequestType;
        set StreamRequestTypeData(value: StreamRequestType);
        get Message(): QueueMessage;
        set Message(value: QueueMessage);
        get has_Message(): boolean;
        get IsError(): boolean;
        set IsError(value: boolean);
        get Error(): string;
        set Error(value: string);
        static fromObject(data: {
            RequestID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Message?: ReturnType<typeof QueueMessage.prototype.toObject>;
            IsError?: boolean;
            Error?: string;
        }): StreamQueueMessagesResponse;
        toObject(): {
            RequestID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Message?: ReturnType<typeof QueueMessage.prototype.toObject>;
            IsError?: boolean;
            Error?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StreamQueueMessagesResponse;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): StreamQueueMessagesResponse;
    }
    export class QueuesUpstreamRequest extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            Messages?: QueueMessage[];
        });
        get RequestID(): string;
        set RequestID(value: string);
        get Messages(): QueueMessage[];
        set Messages(value: QueueMessage[]);
        static fromObject(data: {
            RequestID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
        }): QueuesUpstreamRequest;
        toObject(): {
            RequestID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesUpstreamRequest;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueuesUpstreamRequest;
    }
    export class QueuesUpstreamResponse extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RefRequestID?: string;
            Results?: SendQueueMessageResult[];
            IsError?: boolean;
            Error?: string;
        });
        get RefRequestID(): string;
        set RefRequestID(value: string);
        get Results(): SendQueueMessageResult[];
        set Results(value: SendQueueMessageResult[]);
        get IsError(): boolean;
        set IsError(value: boolean);
        get Error(): string;
        set Error(value: string);
        static fromObject(data: {
            RefRequestID?: string;
            Results?: ReturnType<typeof SendQueueMessageResult.prototype.toObject>[];
            IsError?: boolean;
            Error?: string;
        }): QueuesUpstreamResponse;
        toObject(): {
            RefRequestID?: string;
            Results?: ReturnType<typeof SendQueueMessageResult.prototype.toObject>[];
            IsError?: boolean;
            Error?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesUpstreamResponse;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueuesUpstreamResponse;
    }
    export class QueuesDownstreamRequest extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            ClientID?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Channel?: string;
            MaxItems?: number;
            WaitTimeout?: number;
            AutoAck?: boolean;
            ReQueueChannel?: string;
            SequenceRange?: number[];
            RefTransactionId?: string;
            Metadata?: Map<string, string>;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get ClientID(): string;
        set ClientID(value: string);
        get RequestTypeData(): QueuesDownstreamRequestType;
        set RequestTypeData(value: QueuesDownstreamRequestType);
        get Channel(): string;
        set Channel(value: string);
        get MaxItems(): number;
        set MaxItems(value: number);
        get WaitTimeout(): number;
        set WaitTimeout(value: number);
        get AutoAck(): boolean;
        set AutoAck(value: boolean);
        get ReQueueChannel(): string;
        set ReQueueChannel(value: string);
        get SequenceRange(): number[];
        set SequenceRange(value: number[]);
        get RefTransactionId(): string;
        set RefTransactionId(value: string);
        get Metadata(): Map<string, string>;
        set Metadata(value: Map<string, string>);
        static fromObject(data: {
            RequestID?: string;
            ClientID?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Channel?: string;
            MaxItems?: number;
            WaitTimeout?: number;
            AutoAck?: boolean;
            ReQueueChannel?: string;
            SequenceRange?: number[];
            RefTransactionId?: string;
            Metadata?: {
                [key: string]: string;
            };
        }): QueuesDownstreamRequest;
        toObject(): {
            RequestID?: string;
            ClientID?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Channel?: string;
            MaxItems?: number;
            WaitTimeout?: number;
            AutoAck?: boolean;
            ReQueueChannel?: string;
            SequenceRange?: number[];
            RefTransactionId?: string;
            Metadata?: {
                [key: string]: string;
            };
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesDownstreamRequest;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueuesDownstreamRequest;
    }
    export class QueuesDownstreamResponse extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            TransactionId?: string;
            RefRequestId?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Messages?: QueueMessage[];
            ActiveOffsets?: number[];
            IsError?: boolean;
            Error?: string;
            TransactionComplete?: boolean;
            Metadata?: Map<string, string>;
        });
        get TransactionId(): string;
        set TransactionId(value: string);
        get RefRequestId(): string;
        set RefRequestId(value: string);
        get RequestTypeData(): QueuesDownstreamRequestType;
        set RequestTypeData(value: QueuesDownstreamRequestType);
        get Messages(): QueueMessage[];
        set Messages(value: QueueMessage[]);
        get ActiveOffsets(): number[];
        set ActiveOffsets(value: number[]);
        get IsError(): boolean;
        set IsError(value: boolean);
        get Error(): string;
        set Error(value: string);
        get TransactionComplete(): boolean;
        set TransactionComplete(value: boolean);
        get Metadata(): Map<string, string>;
        set Metadata(value: Map<string, string>);
        static fromObject(data: {
            TransactionId?: string;
            RefRequestId?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
            ActiveOffsets?: number[];
            IsError?: boolean;
            Error?: string;
            TransactionComplete?: boolean;
            Metadata?: {
                [key: string]: string;
            };
        }): QueuesDownstreamResponse;
        toObject(): {
            TransactionId?: string;
            RefRequestId?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
            ActiveOffsets?: number[];
            IsError?: boolean;
            Error?: string;
            TransactionComplete?: boolean;
            Metadata?: {
                [key: string]: string;
            };
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesDownstreamResponse;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueuesDownstreamResponse;
    }
    export class QueueInfo extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            Name?: string;
            Messages?: number;
            Bytes?: number;
            FirstSequence?: number;
            LastSequence?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Subscribers?: number;
        });
        get Name(): string;
        set Name(value: string);
        get Messages(): number;
        set Messages(value: number);
        get Bytes(): number;
        set Bytes(value: number);
        get FirstSequence(): number;
        set FirstSequence(value: number);
        get LastSequence(): number;
        set LastSequence(value: number);
        get Sent(): number;
        set Sent(value: number);
        get Delivered(): number;
        set Delivered(value: number);
        get Waiting(): number;
        set Waiting(value: number);
        get Subscribers(): number;
        set Subscribers(value: number);
        static fromObject(data: {
            Name?: string;
            Messages?: number;
            Bytes?: number;
            FirstSequence?: number;
            LastSequence?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Subscribers?: number;
        }): QueueInfo;
        toObject(): {
            Name?: string;
            Messages?: number;
            Bytes?: number;
            FirstSequence?: number;
            LastSequence?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Subscribers?: number;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueInfo;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueueInfo;
    }
    export class QueuesInfo extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            TotalQueue?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Queues?: QueueInfo[];
        });
        get TotalQueue(): number;
        set TotalQueue(value: number);
        get Sent(): number;
        set Sent(value: number);
        get Delivered(): number;
        set Delivered(value: number);
        get Waiting(): number;
        set Waiting(value: number);
        get Queues(): QueueInfo[];
        set Queues(value: QueueInfo[]);
        static fromObject(data: {
            TotalQueue?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Queues?: ReturnType<typeof QueueInfo.prototype.toObject>[];
        }): QueuesInfo;
        toObject(): {
            TotalQueue?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Queues?: ReturnType<typeof QueueInfo.prototype.toObject>[];
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesInfo;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueuesInfo;
    }
    export class QueuesInfoRequest extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RequestID?: string;
            QueueName?: string;
        });
        get RequestID(): string;
        set RequestID(value: string);
        get QueueName(): string;
        set QueueName(value: string);
        static fromObject(data: {
            RequestID?: string;
            QueueName?: string;
        }): QueuesInfoRequest;
        toObject(): {
            RequestID?: string;
            QueueName?: string;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesInfoRequest;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueuesInfoRequest;
    }
    export class QueuesInfoResponse extends pb_1.Message {
        #private;
        constructor(data?: any[] | {
            RefRequestID?: string;
            Info?: QueuesInfo;
        });
        get RefRequestID(): string;
        set RefRequestID(value: string);
        get Info(): QueuesInfo;
        set Info(value: QueuesInfo);
        get has_Info(): boolean;
        static fromObject(data: {
            RefRequestID?: string;
            Info?: ReturnType<typeof QueuesInfo.prototype.toObject>;
        }): QueuesInfoResponse;
        toObject(): {
            RefRequestID?: string;
            Info?: ReturnType<typeof QueuesInfo.prototype.toObject>;
        };
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesInfoResponse;
        serializeBinary(): Uint8Array;
        static deserializeBinary(bytes: Uint8Array): QueuesInfoResponse;
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    export abstract class UnimplementedkubemqService {
        static definition: {
            SendEvent: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: Event) => Buffer;
                requestDeserialize: (bytes: Buffer) => Event;
                responseSerialize: (message: Result) => Buffer;
                responseDeserialize: (bytes: Buffer) => Result;
            };
            SendEventsStream: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: Event) => Buffer;
                requestDeserialize: (bytes: Buffer) => Event;
                responseSerialize: (message: Result) => Buffer;
                responseDeserialize: (bytes: Buffer) => Result;
            };
            SubscribeToEvents: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: Subscribe) => Buffer;
                requestDeserialize: (bytes: Buffer) => Subscribe;
                responseSerialize: (message: EventReceive) => Buffer;
                responseDeserialize: (bytes: Buffer) => EventReceive;
            };
            SubscribeToRequests: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: Subscribe) => Buffer;
                requestDeserialize: (bytes: Buffer) => Subscribe;
                responseSerialize: (message: Request) => Buffer;
                responseDeserialize: (bytes: Buffer) => Request;
            };
            SendRequest: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: Request) => Buffer;
                requestDeserialize: (bytes: Buffer) => Request;
                responseSerialize: (message: Response) => Buffer;
                responseDeserialize: (bytes: Buffer) => Response;
            };
            SendResponse: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: Response) => Buffer;
                requestDeserialize: (bytes: Buffer) => Response;
                responseSerialize: (message: Empty) => Buffer;
                responseDeserialize: (bytes: Buffer) => Empty;
            };
            SendQueueMessage: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: QueueMessage) => Buffer;
                requestDeserialize: (bytes: Buffer) => QueueMessage;
                responseSerialize: (message: SendQueueMessageResult) => Buffer;
                responseDeserialize: (bytes: Buffer) => SendQueueMessageResult;
            };
            SendQueueMessagesBatch: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: QueueMessagesBatchRequest) => Buffer;
                requestDeserialize: (bytes: Buffer) => QueueMessagesBatchRequest;
                responseSerialize: (message: QueueMessagesBatchResponse) => Buffer;
                responseDeserialize: (bytes: Buffer) => QueueMessagesBatchResponse;
            };
            ReceiveQueueMessages: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: ReceiveQueueMessagesRequest) => Buffer;
                requestDeserialize: (bytes: Buffer) => ReceiveQueueMessagesRequest;
                responseSerialize: (message: ReceiveQueueMessagesResponse) => Buffer;
                responseDeserialize: (bytes: Buffer) => ReceiveQueueMessagesResponse;
            };
            StreamQueueMessage: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: StreamQueueMessagesRequest) => Buffer;
                requestDeserialize: (bytes: Buffer) => StreamQueueMessagesRequest;
                responseSerialize: (message: StreamQueueMessagesResponse) => Buffer;
                responseDeserialize: (bytes: Buffer) => StreamQueueMessagesResponse;
            };
            AckAllQueueMessages: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: AckAllQueueMessagesRequest) => Buffer;
                requestDeserialize: (bytes: Buffer) => AckAllQueueMessagesRequest;
                responseSerialize: (message: AckAllQueueMessagesResponse) => Buffer;
                responseDeserialize: (bytes: Buffer) => AckAllQueueMessagesResponse;
            };
            Ping: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: Empty) => Buffer;
                requestDeserialize: (bytes: Buffer) => Empty;
                responseSerialize: (message: PingResult) => Buffer;
                responseDeserialize: (bytes: Buffer) => PingResult;
            };
            QueuesDownstream: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: QueuesDownstreamRequest) => Buffer;
                requestDeserialize: (bytes: Buffer) => QueuesDownstreamRequest;
                responseSerialize: (message: QueuesDownstreamResponse) => Buffer;
                responseDeserialize: (bytes: Buffer) => QueuesDownstreamResponse;
            };
            QueuesUpstream: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: QueuesUpstreamRequest) => Buffer;
                requestDeserialize: (bytes: Buffer) => QueuesUpstreamRequest;
                responseSerialize: (message: QueuesUpstreamResponse) => Buffer;
                responseDeserialize: (bytes: Buffer) => QueuesUpstreamResponse;
            };
            QueuesInfo: {
                path: string;
                requestStream: boolean;
                responseStream: boolean;
                requestSerialize: (message: QueuesInfoRequest) => Buffer;
                requestDeserialize: (bytes: Buffer) => QueuesInfoRequest;
                responseSerialize: (message: QueuesInfoResponse) => Buffer;
                responseDeserialize: (bytes: Buffer) => QueuesInfoResponse;
            };
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract SendEvent(call: grpc_1.ServerUnaryCall<Event, Result>, callback: grpc_1.sendUnaryData<Result>): void;
        abstract SendEventsStream(call: grpc_1.ServerDuplexStream<Event, Result>): void;
        abstract SubscribeToEvents(call: grpc_1.ServerWritableStream<Subscribe, EventReceive>): void;
        abstract SubscribeToRequests(call: grpc_1.ServerWritableStream<Subscribe, Request>): void;
        abstract SendRequest(call: grpc_1.ServerUnaryCall<Request, Response>, callback: grpc_1.sendUnaryData<Response>): void;
        abstract SendResponse(call: grpc_1.ServerUnaryCall<Response, Empty>, callback: grpc_1.sendUnaryData<Empty>): void;
        abstract SendQueueMessage(call: grpc_1.ServerUnaryCall<QueueMessage, SendQueueMessageResult>, callback: grpc_1.sendUnaryData<SendQueueMessageResult>): void;
        abstract SendQueueMessagesBatch(call: grpc_1.ServerUnaryCall<QueueMessagesBatchRequest, QueueMessagesBatchResponse>, callback: grpc_1.sendUnaryData<QueueMessagesBatchResponse>): void;
        abstract ReceiveQueueMessages(call: grpc_1.ServerUnaryCall<ReceiveQueueMessagesRequest, ReceiveQueueMessagesResponse>, callback: grpc_1.sendUnaryData<ReceiveQueueMessagesResponse>): void;
        abstract StreamQueueMessage(call: grpc_1.ServerDuplexStream<StreamQueueMessagesRequest, StreamQueueMessagesResponse>): void;
        abstract AckAllQueueMessages(call: grpc_1.ServerUnaryCall<AckAllQueueMessagesRequest, AckAllQueueMessagesResponse>, callback: grpc_1.sendUnaryData<AckAllQueueMessagesResponse>): void;
        abstract Ping(call: grpc_1.ServerUnaryCall<Empty, PingResult>, callback: grpc_1.sendUnaryData<PingResult>): void;
        abstract QueuesDownstream(call: grpc_1.ServerDuplexStream<QueuesDownstreamRequest, QueuesDownstreamResponse>): void;
        abstract QueuesUpstream(call: grpc_1.ServerDuplexStream<QueuesUpstreamRequest, QueuesUpstreamResponse>): void;
        abstract QueuesInfo(call: grpc_1.ServerUnaryCall<QueuesInfoRequest, QueuesInfoResponse>, callback: grpc_1.sendUnaryData<QueuesInfoResponse>): void;
    }
    const kubemqClient_base: grpc_1.ServiceClientConstructor;
    export class kubemqClient extends kubemqClient_base {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>);
        SendEvent: GrpcUnaryServiceInterface<Event, Result>;
        SendEventsStream: GrpcChunkServiceInterface<Event, Result>;
        SubscribeToEvents: GrpcStreamServiceInterface<Subscribe, EventReceive>;
        SubscribeToRequests: GrpcStreamServiceInterface<Subscribe, Request>;
        SendRequest: GrpcUnaryServiceInterface<Request, Response>;
        SendResponse: GrpcUnaryServiceInterface<Response, Empty>;
        SendQueueMessage: GrpcUnaryServiceInterface<QueueMessage, SendQueueMessageResult>;
        SendQueueMessagesBatch: GrpcUnaryServiceInterface<QueueMessagesBatchRequest, QueueMessagesBatchResponse>;
        ReceiveQueueMessages: GrpcUnaryServiceInterface<ReceiveQueueMessagesRequest, ReceiveQueueMessagesResponse>;
        StreamQueueMessage: GrpcChunkServiceInterface<StreamQueueMessagesRequest, StreamQueueMessagesResponse>;
        AckAllQueueMessages: GrpcUnaryServiceInterface<AckAllQueueMessagesRequest, AckAllQueueMessagesResponse>;
        Ping: GrpcUnaryServiceInterface<Empty, PingResult>;
        QueuesDownstream: GrpcChunkServiceInterface<QueuesDownstreamRequest, QueuesDownstreamResponse>;
        QueuesUpstream: GrpcChunkServiceInterface<QueuesUpstreamRequest, QueuesUpstreamResponse>;
        QueuesInfo: GrpcUnaryServiceInterface<QueuesInfoRequest, QueuesInfoResponse>;
    }
    export {};
}
//# sourceMappingURL=kubemq.d.ts.map
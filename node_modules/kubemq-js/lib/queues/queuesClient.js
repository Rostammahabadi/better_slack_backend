"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueuesClient = void 0;
const pb = require("../protos");
const KubeMQClient_1 = require("../client/KubeMQClient");
const common_1 = require("../common/common");
const utils_1 = require("../common/utils");
const QueueStreamHelper_1 = require("./QueueStreamHelper");
/**
 * @internal
 */
const toQueueMessagePb = function (msg, defClientId) {
    const pbMessage = new pb.kubemq.QueueMessage();
    pbMessage.MessageID = msg.id ? msg.id : utils_1.Utils.uuid();
    pbMessage.ClientID = msg.clientId ? msg.clientId : defClientId;
    pbMessage.Channel = msg.channel;
    // Convert the string to Uint8Array
    pbMessage.Body =
        typeof msg.body === 'string'
            ? new TextEncoder().encode(msg.body)
            : msg.body;
    pbMessage.Metadata = msg.metadata;
    if (msg.tags != null) {
        pbMessage.Tags = msg.tags;
    }
    if (msg.policy != null) {
        const pbMessagePolicy = new pb.kubemq.QueueMessagePolicy();
        pbMessagePolicy.DelaySeconds = msg.policy.delaySeconds
            ? msg.policy.delaySeconds
            : 0;
        pbMessagePolicy.ExpirationSeconds = msg.policy.expirationSeconds
            ? msg.policy.expirationSeconds
            : 0;
        pbMessagePolicy.MaxReceiveCount = msg.policy.maxReceiveCount
            ? msg.policy.maxReceiveCount
            : 0;
        pbMessagePolicy.MaxReceiveQueue = msg.policy.maxReceiveQueue
            ? msg.policy.maxReceiveQueue
            : '';
        pbMessage.Policy = pbMessagePolicy;
    }
    return pbMessage;
};
/**
 * @internal
 */
const fromPbQueueMessage = function (msg) {
    let msgAttributes = {};
    const receivedMessageAttr = msg.Attributes;
    if (receivedMessageAttr) {
        msgAttributes.delayedTo = receivedMessageAttr.DelayedTo;
        msgAttributes.expirationAt = receivedMessageAttr.ExpirationAt;
        msgAttributes.receiveCount = receivedMessageAttr.ReceiveCount;
        msgAttributes.reRouted = receivedMessageAttr.ReRouted;
        msgAttributes.reRoutedFromQueue = receivedMessageAttr.ReRoutedFromQueue;
        msgAttributes.sequence = msg.Attributes.Sequence;
        msgAttributes.timestamp = msg.Attributes.Timestamp;
    }
    return {
        id: msg.MessageID,
        channel: msg.Channel,
        clientId: msg.ClientID,
        metadata: msg.Metadata,
        body: msg.Body,
        tags: msg.Tags,
        attributes: msgAttributes,
    };
};
/**
 * Queue Client - KubeMQ queues client
 */
class QueuesClient extends KubeMQClient_1.KubeMQClient {
    /**
     * @internal
     */
    constructor(Options) {
        super(Options);
        this.queueStreamHelper = new QueueStreamHelper_1.QueueStreamHelper();
    }
    /**
     * Create new queue channel
     * @param channelName
     * @return Promise<void>
     */
    createQueuesChannel(channelName) {
        return (0, common_1.createChannel)(this.grpcClient, this.getMetadata(), this.clientId, channelName, 'queues');
    }
    /**
     * Delete commands channel
     * @param channelName
     * @return Promise<void>
     */
    deleteQueuesChannel(channelName) {
        return (0, common_1.deleteChannel)(this.grpcClient, this.getMetadata(), this.clientId, channelName, 'queues');
    }
    /**
     * List queues channels
     * @param search
     * @return Promise<QueuesChannel[]>
     */
    listQueuesChannel(search) {
        return (0, common_1.listQueuesChannels)(this.grpcClient, this.getMetadata(), this.clientId, search, 'queues');
    }
    /**
     * Send queue message
     * @param msg
     * @return Promise<QueueMessageSendResult>
     */
    sendQueuesMessage(msg) {
        return new Promise((resolve, reject) => {
            // Generate a unique RequestID for the request
            const requestId = utils_1.Utils.uuid();
            // Create an instance of QueuesUpstreamRequest with the generated RequestID and the message
            const qur = new pb.kubemq.QueuesUpstreamRequest({
                RequestID: requestId,
                Messages: [toQueueMessagePb(msg, this.clientId)], // Wrap the message in an array
            });
            // Use the queueStreamHelper to send the message
            this.queueStreamHelper
                .sendMessage(this, qur)
                .then((response) => {
                resolve({
                    id: response.id,
                    sentAt: response.sentAt,
                    delayedTo: response.delayedTo,
                    error: response.error,
                    expirationAt: response.expirationAt,
                    isError: response.isError,
                });
            })
                .catch((error) => {
                reject(error);
            });
        });
    }
    /**
     * Send queue message
     * @param msg
     * @return Promise<QueueMessageSendResult>
     */
    receiveQueuesMessages(msg) {
        return new Promise((resolve, reject) => {
            // Use the queueStreamHelper to receive the message
            this.queueStreamHelper
                .receiveMessage(this, msg.encode(this.clientId), msg.visibilitySeconds, msg.autoAckMessages)
                .then((response) => {
                // Resolve the promise with the constructed response
                resolve(response);
            })
                .catch((error) => {
                // Reject the promise with the error
                reject(error);
            });
        });
    }
    /**
     * Pulls messages from a queue.
     * @param request
     * @return Promise<QueuesPullPeekMessagesResponse>
     */
    pull(request) {
        return this.pullOrWaiting(request, false);
    }
    /**
     * Get waiting messages from a queue.
     * @param request
     * @return Promise<QueuesPullPeekMessagesResponse>
     */
    waiting(request) {
        return this.pullOrWaiting(request, true);
    }
    /**
     * @internal
     */
    pullOrWaiting(request, isPeek) {
        const pbPullSubRequest = new pb.kubemq.ReceiveQueueMessagesRequest();
        pbPullSubRequest.ClientID = request.clientId
            ? request.clientId
            : this.clientId;
        pbPullSubRequest.Channel = request.channel;
        pbPullSubRequest.IsPeak = false;
        pbPullSubRequest.RequestID = request.id ? request.id : utils_1.Utils.uuid();
        pbPullSubRequest.MaxNumberOfMessages = request.maxNumberOfMessages
            ? request.maxNumberOfMessages
            : 1;
        pbPullSubRequest.WaitTimeSeconds = request.waitTimeoutSeconds
            ? request.waitTimeoutSeconds
            : 0;
        pbPullSubRequest.IsPeak = isPeek;
        return new Promise((resolve, reject) => {
            this.grpcClient.ReceiveQueueMessages(pbPullSubRequest, this.getMetadata(), (e, response) => {
                if (e) {
                    reject(e);
                    return;
                }
                const respMessages = [];
                response.Messages.forEach((msg) => {
                    respMessages.push(fromPbQueueMessage(msg));
                });
                resolve({
                    id: response.RequestID,
                    messages: respMessages,
                    error: response.Error,
                    isError: response.IsError,
                    isPeek: isPeek,
                    messagesExpired: response.MessagesExpired,
                    messagesReceived: response.MessagesReceived,
                });
            });
        });
    }
}
exports.QueuesClient = QueuesClient;
//# sourceMappingURL=queuesClient.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueueStreamHelper = void 0;
const queuesTypes_1 = require("./queuesTypes");
class QueueStreamHelper {
    constructor() {
        this.queuesUpStreamHandler = null;
        this.queuesDownstreamHandler = null;
    }
    /**
     * Sends a message to KubeMQ using a duplex stream.
     * @param kubeMQClient - The KubeMQ client instance.
     * @param queueMessage - The upstream request message to send.
     * @returns A promise that resolves with the result of the send operation.
     */
    async sendMessage(kubeMQClient, queueMessage) {
        return new Promise((resolve, reject) => {
            var _a;
            if (!this.queuesUpStreamHandler) {
                // Create a duplex stream for upstream communication
                const duplexStream = kubeMQClient.grpcClient.QueuesUpstream();
                duplexStream.on('data', (response) => {
                    const result = this.createQueueMessageSendResult(response);
                    resolve(result);
                });
                duplexStream.on('error', (err) => {
                    console.error('Error in QueuesUpstreamResponse:', err);
                    reject(this.createErrorResult(err.message));
                });
                duplexStream.on('end', () => {
                    console.log('QueuesUpstreamResponse stream ended.');
                });
                this.queuesUpStreamHandler = duplexStream;
            }
            // Write the message to the duplex stream
            (_a = this.queuesUpStreamHandler) === null || _a === void 0 ? void 0 : _a.write(queueMessage);
        });
    }
    /**
     * Receives a message from KubeMQ using a duplex stream.
     * @param kubeMQClient - The KubeMQ client instance.
     * @param queuesPollRequest - The downstream request to send.
     * @param visibilitySeconds - Visibility timeout for messages.
     * @param autoAckMessages - Indicates whether messages are auto-acknowledged.
     * @returns A promise that resolves with the pulled message response.
     */
    async receiveMessage(kubeMQClient, queuesPollRequest, visibilitySeconds, autoAckMessages) {
        return new Promise((resolve, reject) => {
            var _a;
            if (!this.queuesDownstreamHandler) {
                // Create a duplex stream for downstream communication
                const duplexStream = kubeMQClient.grpcClient.QueuesDownstream();
                duplexStream.on('data', (response) => {
                    const qpResp = this.createQueuesMessagesPulledResponse(response, visibilitySeconds, autoAckMessages);
                    resolve(qpResp);
                });
                duplexStream.on('error', (err) => {
                    console.error('Error in QueuesDownstreamResponse:', err);
                    reject(this.createErrorResponse(err.message));
                });
                duplexStream.on('end', () => {
                    console.log('QueuesDownstreamResponse stream ended.');
                });
                this.queuesDownstreamHandler = duplexStream;
            }
            // Write the poll request to the duplex stream
            (_a = this.queuesDownstreamHandler) === null || _a === void 0 ? void 0 : _a.write(queuesPollRequest);
        });
    }
    /**
     * Creates a `QueueMessageSendResult` object from the upstream response.
     * @param response - The upstream response from KubeMQ.
     * @returns The constructed `QueueMessageSendResult`.
     */
    createQueueMessageSendResult(response) {
        const result = response.Results[0];
        return {
            id: (result === null || result === void 0 ? void 0 : result.MessageID) || '',
            sentAt: (result === null || result === void 0 ? void 0 : result.SentAt) > 0 ? result.SentAt / 1000000000 : 0,
            expirationAt: (result === null || result === void 0 ? void 0 : result.ExpirationAt) > 0 ? result.ExpirationAt / 1000000000 : 0,
            delayedTo: (result === null || result === void 0 ? void 0 : result.DelayedTo) > 0 ? result.DelayedTo / 1000000000 : 0,
            isError: response.IsError,
            error: response.Error || '',
        };
    }
    /**
     * Creates an error result object for failed upstream messages.
     * @param errorMessage - The error message from the failed operation.
     * @returns The constructed `QueueMessageSendResult` indicating failure.
     */
    createErrorResult(errorMessage) {
        return {
            id: '',
            sentAt: 0,
            expirationAt: 0,
            delayedTo: 0,
            isError: true,
            error: errorMessage,
        };
    }
    /**
     * Creates a `QueuesMessagesPulledResponse` object from the downstream response.
     * @param response - The downstream response from KubeMQ.
     * @param visibilitySeconds - The visibility timeout for pulled messages.
     * @param autoAckMessages - Indicates whether messages are auto-acknowledged.
     * @returns The constructed `QueuesMessagesPulledResponse`.
     */
    createQueuesMessagesPulledResponse(response, visibilitySeconds, autoAckMessages) {
        const pulledResponse = new queuesTypes_1.QueuesMessagesPulledResponse(response.RefRequestId, // id
        [], // messages (empty initially, can be set later)
        response.Messages.length, // messagesReceived
        0, // messagesExpired
        false, // isPeek
        response.IsError, // isError
        response.Error || '', // error
        visibilitySeconds, // visibilitySeconds
        autoAckMessages);
        pulledResponse.activeOffsets = response.ActiveOffsets;
        pulledResponse.responseHandler = this.queuesDownstreamHandler;
        pulledResponse.receiverClientId = response.TransactionId;
        pulledResponse.transactionId = response.TransactionId;
        // Decode the received messages
        for (const message of response.Messages) {
            const decodedMessage = queuesTypes_1.QueueMessageReceived.decode(message, response.TransactionId, response.TransactionComplete, '', // Assuming receiverClientId (could be added as a parameter if needed)
            this.queuesDownstreamHandler, visibilitySeconds, autoAckMessages);
            pulledResponse.messages.push(decodedMessage);
        }
        return pulledResponse;
    }
    /**
     * Creates an error response object for failed downstream messages.
     * @param errorMessage - The error message from the failed operation.
     * @returns The constructed `QueuesMessagesPulledResponse` indicating failure.
     */
    createErrorResponse(errorMessage) {
        return new queuesTypes_1.QueuesMessagesPulledResponse('', // id
        [], // messages (empty)
        0, // messagesReceived
        0, // messagesExpired
        false, // isPeek
        true, // isError (set to true to indicate failure)
        errorMessage, // error message from the failed operation
        0, // visibilitySeconds
        false);
    }
}
exports.QueueStreamHelper = QueueStreamHelper;
//# sourceMappingURL=QueueStreamHelper.js.map